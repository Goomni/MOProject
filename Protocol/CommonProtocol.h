//#ifndef __GODDAMNBUG_ONLINE_PROTOCOL__
//#define __GODDAMNBUG_ONLINE_PROTOCOL__

/*
- 2018.12.11


	# 변경 en_PACKET_MAT_MAS_REQ_GAME_ROOM,
	
		삭제		UINT64	AccountNo			

		매칭서버가 마스터 서버에게 방배정 요청시 AccountNo 정보를 삭제함.
		AccountNo 로 구분하지 않고, ClientKey 만 가지고 구분하도록 함.


	# 변경 en_PACKET_CS_MATCH_RES_GAME_ROOM,

		추가		INT64	ClientKey

		매칭서버가 클라이언트에게 방배정 정보를 줄때 매칭서버에서 생성시킨
		ClientKey 를 같이 보내줌.

		클라이언트는 이를 가지고 배틀서버로 들어감.


	# 변경 en_PACKET_CS_GAME_REQ_LOGIN,

		추가		INT64	ClientKey

		클라이언트가 배틀서버에 로그인시 자신의 ClientKey 를 들고 들어감
		ClientKey 는 매칭서버에서 받았음.


	# 변경 en_PACKET_BAT_MAS_REQ_LEFT_USER,
	
		삭제		INT64	AccountNo
		추가		INT64	ClientKey

		배틀서버 대기방에서 유저 퇴장시에
		마스터 서버에게 주던 AccountNo 를 ClientKey 로 변경





- 2018.10.30

	# 추가 en_PACKET_CS_GAME_RES_REDZONE_ALERT_FINAL,
	# 추가 en_PACKET_CS_GAME_RES_REDZONE_ACTIVE_FINAL,

		마지막 레드존 컨텐츠 패킷 추가



- 2018.10.14

	# 추가 en_PACKET_CS_GAME_RES_HELMET_CREATE
	# 추가 en_PACKET_CS_GAME_REQ_HELMET_GET
	# 추가 en_PACKET_CS_GAME_RES_HELMET_GET

		헬멧 아이템 관련 패킷 추가

	# 변경 en_PACKET_CS_GAME_RES_HIT_DAMAGE

		추가		BYTE	HelmetHit
		추가		int		HelmetCount

		총 피격시 헬멧방어 횟수를 확인하여 헬멧히트인지 여부가 추가 됨.
		헬멧히트 남은 개수도 추가 됨.



- 2018.10.10

	# 변경 en_PACKET_CS_GAME_REQ_RELOAD

		본 패킷은 변화가 없으나 이에대한 로직이 변경됨.

		기존 -	그냥 다른 유저에게 RES 를 뿌려줌.
		변경 -	탄창개수 확인 후 탄창이 있다면 -1  없으면 총알 개수를 0 으로 만들고 진행
				총알 개수를 g_Data_Cartridge_Bullet 로 변경
				모든 유저에게 RES 를 뿌려줌 (자신 포함)

	# 변경 en_PACKET_CS_GAME_RES_RELOAD,

		추가		INT		Bullet
		추가		INT		Cartridge

		서버에서 총알 개수와 탄창 개수를 카운팅 하므로 현재 상태를 모든 유저에게 뿌려줌


	# 변경 en_PACKET_CS_GAME_REQ_FIRE1

		패킷의 변화는 없으나 서버에서 총알 수를 카운틍 해야 함
		총알이 0 이라면 패킷을 무시 해버림. (내 클라이언트 화면에선 총을 쏘지만 동작이 안됨)

		또한 FIRE1 발사 확인 후 100ms 이내에 HitDamage 가 와야만 인정하도록 함


	# 변경 en_PACKET_CS_GAME_REQ_HIT_DAMAGE

		패킷의 변경은 없으며 로직이 변경 되어야 함
		- 서버에서는 Fire1 이후 100ms 내에 HitDamage 가 오는 경우만 처리 하도록 함.
		- 서버에서는 헬멧 방어 횟수를 카운팅하며 헬멧이 있는 경우는 데미지를 먹이지 않고 헬멧 - 1 만 함.


- 2018.10.06

	# 추가 en_PACKET_CS_GAME_RES_CARTRIDGE_CREATE,
	# 추가 en_PACKET_CS_GAME_REQ_CARTRIDGE_GET,
	# 추가 en_PACKET_CS_GAME_RES_CARTRIDGE_GET,

		탄창 아이템 추가.
		무한정 총알 장전(리로드) 가 안되며, 보유한 탄창 수만큼 리로드 가능



	# 변경 en_PACKET_CS_GAME_RES_CREATE_MY_CHARACTER,
	
		추가 int	  Bullet		// 초기 총알 개수 

		// 서버에서 모든 플레이어의 총알개수를 가지고 카운팅 하면서 확인작업을 하도록 함.
		// 최초 총알 개수는 g_Cartridge_Bullet 변수를 쓴다


	# 변경 en_PACKET_CS_GAME_RES_CREATE_OTHER_CHARACTER,
	
		추가 int	  Bullet		// 초기 총알 개수




- 2018.10.01

	# 추가 en_PACKET_CS_GAME_REQ_FIRE2
	# 추가 en_PACKET_CS_GAME_RES_FIRE2

		발차기 패킷 추가
		서버에서는 그냥 다른 유저에게 RES 뿌려주면 됨.


	# 추가 en_PACKET_CS_GAME_REQ_KICK_DAMAGE
	# 추가 en_PACKET_CS_GAME_RES_KICK_DAMAGE

		발차기 데미지 패킷 추가
		해당 REQ 가 오면 거리 판정하여 데미지 먹인 후 (2 미만인 경우만) RES 를 전체에 뿌림
		
		g_Data_KickDamage 변수 사용

- 2018.05.07

	# 변경 en_PACKET_MAT_MAS_REQ_GAME_ROOM,
		
		추가 UINT64	AccountNo			

		마스터 서버는 사용자의 고유 값으로 매칭서버가 생성한 ClientKey 만을 알고 있었기에
		AccountNo 를 추가하여 마스터는 ClientKey / AccountNo 를 쌍으로 관리 사용 한다.



	# 변경 en_PACKET_BAT_MAS_REQ_LEFT_USER
	
		추가 INT64	AccountNo

		배틀이 마스터에게 대기방에서 사용자 나감을 알릴때 AccountNo 항목 추가 됨.
		en_PACKET_BAT_MAS_REQ_LEFT_USER 주석 부분 참고



-------------------------------------------------
2017.12.19

	# 변경 : en_PACKET_CS_CHAT_REQ_LOGIN

		삭제		char	SessionKey[64];
		추가		char	ConnectToken[32];

		채팅서버가 기존 로그인서버 연결 방식에서 배틀서버 연결로 변경 되면서
		사용자의 세션키 인증이 아닌 연결 자체만 확인하는 ConnectToken 방식으로 변경

		채팅서버는 배틀서버로부터 받은 ConnectToken 을 들고 있으며, 사용자의 접속시 비교한다.




*/
enum en_PACKET_TYPE
{
	////////////////////////////////////////////////////////
	//
	//	Client & Server Protocol
	//
	////////////////////////////////////////////////////////


	////////////////////////////////////////////////////////
	//------------------------------------------------------
	// Chatting Server
	//------------------------------------------------------
	en_PACKET_CS_CHAT_SERVER			= 0,

	//------------------------------------------------------------
	// 채팅서버 로그인 요청
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		WCHAR	ID[20]				// null 포함
	//		WCHAR	Nickname[20]		// null 포함
	//		char	ConnectToken[32];
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_CHAT_REQ_LOGIN,

	//------------------------------------------------------------
	// 채팅서버 로그인 응답
	//
	//	{
	//		WORD	Type
	//
	//		BYTE	Status				// 0:실패	1:성공
	//		INT64	AccountNo
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_CHAT_RES_LOGIN,

	//------------------------------------------------------------
	// 채팅서버 방 입장
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		int		RoomNo
	//		char	EnterToken[32]
	//	}
	//
	//------------------------------------------------------------
	// en_PACKET_CS_CHAT_REQ_SECTOR_MOVE	기존 패킷 삭제
	en_PACKET_CS_CHAT_REQ_ENTER_ROOM,

	//------------------------------------------------------------
	// 채팅서버 방 입장 결과
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		int		RoomNo
	//		BYTE	Status					1: 성공
	//										2: Token 오류
	//										3: 없는 방
	//	}
	//
	//------------------------------------------------------------
	// en_PACKET_CS_CHAT_RES_SECTOR_MOVE	기존 패킷 삭제
	en_PACKET_CS_CHAT_RES_ENTER_ROOM,

	//------------------------------------------------------------
	// 채팅서버 채팅보내기 요청
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		WORD	MessageLen
	//		WCHAR	Message[MessageLen / 2]		// null 미포함
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_CHAT_REQ_MESSAGE,

	//------------------------------------------------------------
	// 채팅서버 채팅보내기 응답  (다른 클라가 보낸 채팅도 이걸로 받음)
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		WCHAR	ID[20]						// null 포함
	//		WCHAR	Nickname[20]				// null 포함
	//		
	//		WORD	MessageLen
	//		WCHAR	Message[MessageLen / 2]		// null 미포함
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_CHAT_RES_MESSAGE,

	//------------------------------------------------------------
	// 하트비트
	//
	//	{
	//		WORD		Type
	//	}
	//
	//
	// 클라이언트는 이를 30초마다 보내줌.
	// 서버는 40초 이상동안 메시지 수신이 없는 클라이언트를 강제로 끊어줘야 함.
	//------------------------------------------------------------	
	en_PACKET_CS_CHAT_REQ_HEARTBEAT,









	////////////////////////////////////////////////////////
	//------------------------------------------------------
	// Login Server
	//------------------------------------------------------
	en_PACKET_CS_LOGIN_SERVER				= 100,


	////////////////////////////////////////////////////////
	//------------------------------------------------------
	// Battle Server
	//------------------------------------------------------
	en_PACKET_CS_GAME_SERVER				= 1000,


	//------------------------------------------------------------
	// 배틀서버로 클라이언트 로그인 요청
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		char	SessionKey[64]
	//
	//		char	ConnectToken[32]
	//		UINT	Ver_Code
	//
	//		INT64	ClientKey
	//	}
	//
	//	배틀서버로 로그인 시 사용자의 SessionKey 확인과 ConnectToken 을 확인 한다.
	//	SessionKey 를 배틀서버가 shDB 를 통해 확인하는 과정이 부담스러울 수 있으나 사용자 인증이 필요하므로 어쩔 수 업음
	//
	//	SessionKey 를 매칭서버 -> 마스터서버 -> 배틀서버 경로로 전달하여  배틀서버가 shDB 조회하는 부분을 줄일 수 는 있겠으나
	//	이것 또한 더 부담되며, 배틀서버는 어차피 닉네임 등 계정정보 확인을 위해서 shDB 를 조회 해아 함.
	//
	//	배틀서버는 로그인요청 수신시 shDB 를통해 세션키 확인 / 계정정보 획득 / ConnectToken 확인 (AUTH 스레드)
	//	유저가 방 입장 후 게임플레이 전환 전 까지는 계속 AUTH 스레드에 머물도록 한다.
	//
	//  배틀서버 버전코드 들어감.  단순 숫자가 아니며 고유한 코드값.
	//	클라이언트는 매칭서버에서 받은 ClientKey 를 들고가므로 배틀역시 ClientKey 를 관리 한다.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_LOGIN,

	//------------------------------------------------------------
	// 로그인 응답
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		BYTE	Result			//	1 : 성공 
	//									2 : 사용자 오류
	//									3 : 세션키 오류
	//									5 : 버전오류
	//									6 : 중복로그인 (기존사용자 / 이번사용자 모두 끊음)
	//	}
	//
	//	응답의 AccountNo 는 별 필요는 없으나 정확한 테스트를 위해서 넣음.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_LOGIN,


	//------------------------------------------------------------
	// 배틀서버의 방에 입장 요청
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		int		RoomNo
	//
	//		char	EnterToken[32]
	//	}
	//
	//	배틀서버의 특정 방에 입장을 요청한다.
	//	사용자의 AccountNo 는 버그 감지 및 테스트를 위해서 넣은 데이터 임.
	//
	//	배틀서버에서는 어떤 방에 어떤 유저가 들어올지는 알지 못하는 상태이므로
	//	EnterToken 만 일치 한다면 입장을 허용 한다.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_ENTER_ROOM,

	//------------------------------------------------------------
	// 방 입장 응답
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		int		RoomNo
	//		BYTE	MaxUser				// 플레이 인원
	//
	//		BYTE	Result				//	1 : 성공
	//									//	2 : EnterToken 불일치
	//									//	3 : 대기방 아님
	//									//	4 : 방 없음
	//									//	5 : 방 가득 참 -- 무시 해도 됨
	//	}
	//
	//	AccountNo 와 RoomNo 는 테스트 및 버그 확인을 위해 넣은 응답 데이터이며, 실제로는 없어도 됨.
	//	(더미에서 잘못된 패킷 수신을 확인하기 위해 있는 용도)
	//
	//	사용자가 방 입장에 성공을 했더라도 이 유저는 AUTH 모드를 유지한다.
	//	실제로 플레이 상태가 되어야만 해당 방과 사용자들을 GAME 모드로 전환 한다.
	//
	//	# 사용자가 방을 나간다는 패킷은 별도로 없음.
	//	# 대기 방에서 접속을 종료하면 그냥 나가는 것으로 처리 함.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_ENTER_ROOM,






	//------------------------------------------------------------
	// 배틀서버 대기방 플레이 준비.
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		BYTE	ReadySec		// 플레이 준비 시간, 초		기본 10초
	//	}
	//
	//	특정 방이 플레이를 위한 준비 카운트 다운 돌입.
	//	해당 방의 모든 유저에게 전달 한다.
	//
	//	배틀서버는 방의 인원이 모두 모이면 [대기방] 을 플레이를 위한 [준비방] 으로 전환 한다.
	//	역시나 아직 AUTH 모드 상태이다.
	//
	//	준비방이 되면 Closed 상태가 되며, 추가적인 입장은 불가능 하다.
	//	이때 나간 유저는 그냥 나가는 것이며 인원이 적어졌더라도 플레이는 진행 한다.
	//	모든 유저가 나가버렸다면 방은 파괴 된다.
	//
	//	WaitSec 시간이 되면 플레이 상태로 전환 한다. (이 때 다시 클라에게 패킷 송신)
	//
	//	서버가 클라에게 통보만 하고 응답은 받지 않음.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_PLAY_READY,


	//------------------------------------------------------------
	// 배틀서버 대기방 플레이 시작
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//	}
	//
	//	게임 시작,
	//	해당 방의 모든 유저에게 전달 한다.
	//	
	//	플레이 상태 (GAME 모드) 로 전환.
	//
	//
	//	본 게임은 대기방시 인원 목록만 나오며 카운트 다운 후 게임씬으로 전환 된다.
	//	만약 배틀그라운드 처럼 대기중인 상태에서도 플레이가 되는 게임이라면 대기모드 상태 역시 하나의 게임으로 보아야 함
	//
	//	이후는 실제 게임 진행 컨텐츠로 ... ~
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_PLAY_START,



	//------------------------------------------------------------
	// 배틀서버 방에 유저가 추가 됨.
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		INT64	AccountNo
	//		WCHAR	Nickname[20]
	//
	//		int		Record_PlayCount	// 플레이 횟수
	//		int		Record_PlayTime		// 플레이 시간 초단위
	//		int		Record_Kill			// 죽인 횟수
	//		int		Record_Die			// 죽은 횟수
	//		int		Record_Win			// 최종승리 횟수
	//	}
	//
	//	대기중인 방에 유저가 추가됨을 알림 /
	//	
	//	- 내가 대기방에 입장 할 때 기존에 있던 유저들의 정보 (여러명이 있는 경우 개별패킷으로 전달)
	//	- 대기방에 들어가 있는데 다른 유저가 들어왔다는 정보
	//  - 자기 자신의 입장도 자신에게 본 패킷을 보내준다. (클라이언트 로직의 간결화를 위해 자신에게도 보내는걸로 함)
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_ADD_USER,

	//------------------------------------------------------------
	// 배틀서버 방에서 유저가 나감 (AUTH 전용)
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		INT64	AccountNo
	//	}
	//
	//	대기중인 방에서 유저가 나감을 알림
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_REMOVE_USER,



	//-----------------------------------------------------------
	//-----------------------------------------------------------
	// 여기부터는 GAME_MODE 스레드 처리 패킷
	//-----------------------------------------------------------
	//-----------------------------------------------------------

	//------------------------------------------------------------
	// 내 캐릭터 생성
	//
	//	{
	//		WORD	Type
	//		
	//		float	PosX
	//		float	PosY
	//
	//		int		HP
	//		int		Bullet		// 초기 총알 개수
	//
	//	}
	//
	// GAME 모드로 전환시 캐릭터 게임 컨텐츠를 셋팅하면서 보냄
	//
	// 서버에서 모든 플레이어의 총알개수를 가지고 카운팅 하면서 확인작업을 하도록 함.
	// 최초 총알 개수는 g_Cartridge_Bullet 변수를 쓴다
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_CREATE_MY_CHARACTER,

	//------------------------------------------------------------
	// 다른유저 캐릭터 생성
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		WCHAR	Nickname[20]
	//
	//		float	PosX
	//		float	PosY
	//
	//		int		HP
	//		int		Bullet
	//	}
	//
	//  GAME 모드로 전환시 캐릭터 게임 컨텐츠를 셋팅하면서 보냄
	//
	// 서버에서 모든 플레이어의 총알개수를 가지고 카운팅 하면서 확인작업을 하도록 함.
	// 최초 총알 개수는 g_Cartridge_Bullet 변수를 쓴다
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_CREATE_OTHER_CHARACTER,



	//------------------------------------------------------------
	// 캐릭터 이동
	//
	//	{
	//		WORD	Type
	//
	//		float	MoveTargetX
	//		float	MoveTargetY
	//		float	MoveTargetZ
	//
	//		float	HitPointX
	//		float	HitPointY
	//		float	HitPointZ
	//	}
	//
	//
	//	MoveTarget 캐릭터가 이동할 목적지
	//	HitPoint 캐릭터가 바라보는 위치 (시야 및 총발사 타겟)
	//	
	//	서버는 이 정보를 그대로 저장하며, 그대로 다른 유저에게 뿌려준다.
	//	서버에서는 별도로 이동이 없으며 클라이언트의 정보를 저장과 릴레이하는 역할만 함.
	//
	//	별도의 정지는 없으며 다른 유저의 화면에서 내 캐릭터는 같은 목적지까지 이동만을 하면 된다.
	//
	//	실제 클라이언트에서 Y 축은 사용되지 않으며, Z 축이 맵에서의 Y 와 같은 역할을 함. Y 는 높이개념
	//	이는 서버가 구분할 필요는 없으며 참고로 알아두면 됨.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_MOVE_PLAYER,

	//------------------------------------------------------------
	// 캐릭터 이동 (자신에게는 보내지 않음)
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//
	//		float	MoveTargetX
	//		float	MoveTargetY
	//		float	MoveTargetZ
	//
	//		float	HitPointX
	//		float	HitPointY
	//		float	HitPointZ
	//	}
	//
	//	위에서 받은 패킷을 그대로 다른 유저에게 전달한다.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_MOVE_PLAYER,

	//------------------------------------------------------------
	// 캐릭터 HitPoint (자신에게는 보내지 않음)
	//
	//	{
	//		WORD	Type
	//
	//		float	HitPointX
	//		float	HitPointY
	//		float	HitPointZ
	//	}
	//
	//	캐릭터가 바라보는 시점으로 일정시간마다 반복적으로 보냄
	//	서버는 이를 다른 유저에게 보내준다.
	//
	//	실시간으로 보낼 필요는 없으나 시야 동기화를 위해서 보냄
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_HIT_POINT,

	//------------------------------------------------------------
	// 캐릭터 HitPoint 
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//
	//		float	HitPointX
	//		float	HitPointY
	//		float	HitPointZ
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_HIT_POINT,




	//------------------------------------------------------------
	// Fire1 발사 (총 발사)
	//
	//	{
	//		WORD	Type
	//
	//		float	HitPointX
	//		float	HitPointY
	//		float	HitPointZ
	//	}
	//
	//	총 발사. 발사 Target 지점을 보냄.
	//
	//	서버는 다른 유저에게 RES 패킷을 뿌림
	//	총에 맞은 오브젝트는 별도의 패킷으로 전송
	//
	//	서버는 총알 개수를 카운팅 해야하며, 총알이 없는경우 패킷을 무시해야함
	//	또한 총알 발사 후 100ms 이내에 HitDamage 패킷이 오는 경우에만 타격으로 인정 하도록 함.
	//
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_FIRE1,


	//------------------------------------------------------------
	// Fire1 발사 (총 발사)
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		float	HitPointX
	//		float	HitPointY
	//		float	HitPointZ
	//	}
	//
	//	총 발사. 발사 Target 을 보냄.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_FIRE1,




	//------------------------------------------------------------
	// Fire2 발차기
	//
	//	{
	//		WORD	Type
	//
	//		float	HitPointX
	//		float	HitPointY
	//		float	HitPointZ
	//	}
	//
	//	발차기. Target 지점을 보냄 (방향으로 사용)
	//
	//	서버는 다른 유저에게 RES 패킷을 뿌림
	//	피격 오브젝트는 별도의 패킷으로 전송
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_FIRE2,


	//------------------------------------------------------------
	// Fire2 발차기
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		float	HitPointX
	//		float	HitPointY
	//		float	HitPointZ
	//	}
	//
	//	발차기 Target 을 보냄.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_FIRE2,





	//------------------------------------------------------------
	// Reload Request
	//
	//	{
	//		WORD	Type
	//	}
	//
	//
	//	총알 재장전. 
	//
	//	서버는 본 패킷을 모든 유저에게 뿌림
	//
	//	1. 서버에서는 해당 플레이어의 탄창 개수를 확인
	//	2. 탄창이 없다면 총알을 0 으로
	//	3. 탄창이 있다면 탄창 -1 후  총알을 g_Data_Cartridge_Bullet 로 셋팅
	//
	//	그리고 모든 플레이어에게 아래의 결과를 뿌려준다 (자신 포함)
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_RELOAD,

	//------------------------------------------------------------
	// Reload Response
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		INT		Bullet
	//		INT		Cartridge
	//	}
	//
	//	리로드 결과는 모든 플레이어가 받음.
	//
	//	클라이언트에서 재장전한 자신은 이미 재장전 액션에 들어갔으므로 재장전 액션은 하지 않음.
	//	다른 유저들은 재장전 액션을 취하며 카트리지 총알 개수를 반영한다.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_RELOAD,


	
	//------------------------------------------------------------
	// HitDamage
	//
	//	{
	//		WORD	Type
	//
	//		INT64	TargetAccountNo		// 피해자 AccountNo
	//	}
	//
	//	공격자의 타격 패킷.
	//
	//	총알 발사 후 (Fire1) 100ms 이내에 본 패킷이 오는 경우만 인정함.
	//
	//	공격자가 클라이언트에서 총 발사 후 타격 판정시 공격자 클라이언트에서 피격 처리 후
	//	서버에 본 패킷을 전송 함.  
	//
	//	서버에서는 데미지 처리 HP 차감 후 모든 클라이언트에게 RES 결과를 보내준다.
	//	피격은 클라이언트가 결정 하지만 HP 차감 계산은 서버가 전담 함.
	//
	//  데미지는 서버에서 거리에따라 다르게 처리 하도록 함
	//
	//	#	상대방이 헬멧방어 횟수가 있는 경우는 이를 1 차감하며
	//	#	데미지를 먹이지 않는다. RES 결과 패킷에도 이를 표기하여 보내준다.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_HIT_DAMAGE,


	//------------------------------------------------------------
	// HitDamage
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AttackerAccountNo	// 공격자 AccountNo
	//		INT64	TargetAccountNo		// 피해자 AccountNo
	//		int		TargetHP			// 피해자의 현재 Total HP
	//
	//		BYTE	HelmetHit			// 0:데미지먹음 , 1:헬멧히트 헬멧차감. 데미지 없음
	//		int		HelmetCount			// 남은 헬멧 방어 횟수
	//	}
	//
	//	피격 결과  패킷.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_HIT_DAMAGE,


	//------------------------------------------------------------
	// KickDamage
	//
	//	{
	//		WORD	Type
	//
	//		INT64	TargetAccountNo		// 피해자 AccountNo
	//	}
	//
	//	발차기 공격자의 타격 패킷
	//
	//	공격자가 클라이언트에서 킥 후 타격 판정시 공격자 클라이언트에서 피격 처리 피터짐 후
	//	서버에 본 패킷을 전송 함.  
	//
	//	서버에서는 데미지 처리 HP 차감 후 모든 클라이언트에게 RES 결과를 보내준다.
	//	피격은 클라이언트가 결정 하지만 HP 차감 계산은 서버가 전담 함.
	//
	//  데미지는 서버에서 거리에따라 타격 성공 여부를 판단 (좌표 거리가 2 이상이면 무시)
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_KICK_DAMAGE,


	//------------------------------------------------------------
	// KickDamage
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AttackerAccountNo	// 공격자 AccountNo
	//		INT64	TargetAccountNo		// 피해자 AccountNo
	//		int		TargetHP			// 피해자의 현재 Total HP
	//	}
	//
	//	발차기 결과  패킷.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_KICK_DAMAGE,



	//------------------------------------------------------------
	// RedZone Damage
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		int		HP				// 데미지 계산된 현재의 총 HP
	//	}
	//
	//	레드존 구역으로 인한 데미지시 패킷.
	//	클라이언트는 이 패킷을 받으면 화면에 피 이펙트를 터트림.
	//	레드존 피해가 눈에 띄지 않아서 별도로 처리 함.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_REDZONE_DAMAGE,


	//------------------------------------------------------------
	// Die
	//
	//	{
	//		WORD	Type
	//
	//		INT64	DieAccountNo
	//	}
	//
	//	특정 플레이어의 사망
	//	서버에서 플레이어 HP 가 0이 되었을때 서버에서 해당 플레이어를 죽음처리 하고
	//	본 패킷을 방 전체에 뿌린다.
	//
	//	죽음 처리라는건 죽었다는 플래그 정도, 죽은 유저는 움직이거나 컨텐츠 처리를 하지 않아야 함
	//	다만 죽었다고 삭제시키는 것은 아님.
	//
	//	플레이어의 삭제는 해당 세션이 종료 되었을 경우에만 함.
	//	죽어도 채팅은 하면서 접속을 유지할 수 있음.
	//
	//	죽을 당시 탄창을 1개 이상 가지고 있었다면 죽은 위치 주변에 탄창 1개 생성
	//	추가로 메디킷 또는 헬멧 둘정 1개를 생성
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_DIE,



	//------------------------------------------------------------
	// RedZone 경고
	//
	//	{
	//		WORD	Type
	//
	//		BYTE	AlertTimeSec
	//	}
	//
	//  서버는 40초마다 새로운 레드존이 활성화 되는데 활성화 20초 전에 해당 경고를 해줌.
	//  방의 모든 유저에게 뿌림
	//	클라이언트는 이를 받아서 해당 구역을 깜빡이도록 함.  
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_REDZONE_ALERT_LEFT,
	en_PACKET_CS_GAME_RES_REDZONE_ALERT_TOP,
	en_PACKET_CS_GAME_RES_REDZONE_ALERT_RIGHT,
	en_PACKET_CS_GAME_RES_REDZONE_ALERT_BOTTOM,

	//------------------------------------------------------------
	// RedZone 활성화
	//
	//	{
	//		WORD	Type
	//	}
	//
	//  실제로 활성화 될때 해당 패킷을 전체 유저에게 보냄.
	//	이후 부터는 해당구역의 플레이어에게 1초마다 1데미지를 먹임. (en_PACKET_CS_GAME_RES_REDZONE_DAMAGE)
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_REDZONE_ACTIVE_LEFT,
	en_PACKET_CS_GAME_RES_REDZONE_ACTIVE_TOP,
	en_PACKET_CS_GAME_RES_REDZONE_ACTIVE_RIGHT,
	en_PACKET_CS_GAME_RES_REDZONE_ACTIVE_BOTTOM,


	//------------------------------------------------------------
	// 마지막 RedZone 경고
	//
	//	{
	//		WORD	Type
	//
	//		BYTE	AlertTimeSec
	//		BYTE	RedZoneType			// 마지막 레드존 타입. (1,2,3,4)
	//	}
	//
	//  4개 레드존 구역이 활성화 된 40초 뒤에  20초 후 마지막 레드존 활성화 경고가 발생
	//  마지막 레드존은 Type1,2,3,4 중 1개만 활성화.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_REDZONE_ALERT_FINAL,

	//------------------------------------------------------------
	// 마지막 RedZone 활성화
	//
	//	{
	//		WORD	Type
	//
	//		BYTE	RedZoneType			// 마지막 레드존 타입. (1,2,3,4)
	//	}
	//
	//  가장 마지막에 추가되는 Final 
	//	이후 부터는 기존 레드존 처리를 무시하고 해당구역 외의 플레이어에게 1초마다 1데미지를 먹임. (en_PACKET_CS_GAME_RES_REDZONE_DAMAGE)
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_REDZONE_ACTIVE_FINAL,


	//------------------------------------------------------------
	// 메드킷 (HP 템) 생성
	//
	//	{
	//		WORD	Type
	//
	//		UINT	MedKit ID		// 아이템 고유 번호  ( ++ 시키는 값)
	//		float	PosX			
	//		float	PosY
	//	}
	//
	//	1. 유저 사망시 해당 위치에 헬멧 또는 메디킷 생성 후 전체 유저에게 뿌림 / 여러 아이템이 동시에 떨어지므로 적절히 좌표 계산
	//	2. 게임 시작시 적절한 위치에 랜덤하게 메디킷을 생성시켜 줌.
	//
	//	플레이어의 좌표는 클라리언트 좌표의 MoveTargetX - PosX / MoveTargetZ - PosY 임
	//	
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_MEDKIT_CREATE,

	//------------------------------------------------------------
	// 메드킷 획득 요청
	//
	//	{
	//		WORD	Type
	//
	//		UINT	MedKit ID		// 메드킷 고유 번호  ( ++ 시키는 값)
	//	}
	//
	//	플레이어가 메드킷에 닿았을때 서버로 이 패킷을 보냄.
	//
	//	서버는 해당 메드킷 좌표와, 해당 플레이어의 좌표를 확인하여 X,Y 각 축이 +2 ~ -2 오차범위 내라면
	//	획득으로 확인하여, 메드킷 삭제 / HP 보상 (g_DataHP / 2 만큼 + 시킴) 후 결과 패킷을 전체에 뿌림. 
	//	
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_MEDKIT_GET,

	//------------------------------------------------------------
	// 메드킷 획득 결과
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		UINT	MedKit ID		// 메드킷 고유 번호
	//		int		HP				// 치료 후 전체 HP
	//	}
	//
	//	메드킷 획득의 결과.	
	//
	//	만약 메드킷 획득 요청 확인시 거리문제 또는 존재하지 않는 매드킷 ID 라면 결과없이 무시한다.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_MEDKIT_GET,



	//------------------------------------------------------------
	// 탄창 템 생성
	//
	//	{
	//		WORD	Type
	//
	//		UINT	Cartridge ID		// 아이템 고유 번호 ( ++ 시키는 값  전체 아이템 대상 고유)
	//		float	PosX			
	//		float	PosY
	//	}
	//
	//	1. 유저 사망시 해당 위치에 탄창을 생성 후 전체 유저에게 뿌림 / 여러 아이템이 동시에 떨어지므로 적절히 좌표 계산
	//	2. 게임 시작시 적절한 위치에 랜덤하게 탄창을 생성시켜 줌.
	//
	//	플레이어의 좌표는 클라리언트 좌표의 MoveTargetX - PosX / MoveTargetZ - PosY 임
	//	
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_CARTRIDGE_CREATE,

	//------------------------------------------------------------
	// 탄창 획득 요청
	//
	//	{
	//		WORD	Type
	//
	//		UINT	Cartridge ID		// 탄창 고유 번호
	//	}
	//
	//	플레이어가 총(탄창) 에 닿았을때 서버로 이 패킷을 보냄.
	//
	//	서버는 해당 탄창의 좌표와, 해당 플레이어의 좌표를 확인하여 X,Y 각 축이 +2 ~ -2 오차범위 내라면
	//	획득으로 확인하여, 탄창 삭제 / 보유 탄창 + 1 후 결과 패킷을 전체에 뿌림. 
	//	
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_CARTRIDGE_GET,

	//------------------------------------------------------------
	// 탄창 획득 결과
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		UINT	CartridgeID			// 탄창 고유 번호
	//		int		CartridgeCount		// 탄창 획득 후 보유 탄창개수
	//	}
	//
	//	탄창 획득의 결과.	
	//
	//	만약 탄창 획득 요청 확인시 거리문제 또는 존재하지 않는 탄창 ID 라면 결과없이 무시한다.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_CARTRIDGE_GET,



	//------------------------------------------------------------
	// 헬멧 템 생성
	//
	//	{
	//		WORD	Type
	//
	//		UINT	Helmet ID		// 아이템 고유 번호 ( ++ 시키는 값  전체 아이템 대상 고유)
	//		float	PosX			
	//		float	PosY
	//	}
	//
	//	1. 유저 사망시 해당 위치에 헬멧을 생성 후 전체 유저에게 뿌림 / 여러 아이템이 동시에 떨어지므로 적절히 좌표 계산
	//	2. 게임 시작시 적절한 위치에 랜덤하게 헬멧을 생성시켜 줌.
	//
	//	플레이어의 좌표는 클라이언트 좌표의 MoveTargetX - PosX / MoveTargetZ - PosY 임
	//	
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_HELMET_CREATE,

	//------------------------------------------------------------
	// 헬멧 획득 요청
	//
	//	{
	//		WORD	Type
	//
	//		UINT	Helmet ID		// 헬멧 고유 번호
	//	}
	//
	//	플레이어가 헬멧에 닿았을때 서버로 이 패킷을 보냄.
	//
	//	서버는 해당 헬멧의 좌표와, 해당 플레이어의 좌표를 확인하여 X,Y 각 축이 +2 ~ -2 오차범위 내라면
	//	획득으로 확인하여, 헬멧 아이템 삭제 / 보유 헬멧 + g_Data_HelmetDefensive 후 결과 패킷을 전체에 뿌림. 
	//	
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_HELMET_GET,

	//------------------------------------------------------------
	// 헬멧 획득 결과
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		UINT	HelmetID			// 헬멧 고유 번호
	//		int		HelmetCount			// 헬멧 획득 후 보유 헬멧방어력수
	//	}
	//
	//	헬멧 획득의 결과.	
	//
	//	만약 헬멧 획득 요청 확인시 거리문제 또는 존재하지 않는 헬멧 ID 라면 결과없이 무시한다.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_HELMET_GET,






	//------------------------------------------------------------
	// Winner
	//
	//	{
	//		WORD	Type
	//	}
	//
	//	최종 1명의 플레이어가 살아 남았을때 해당 플레이어에게 본 패킷 전송
	//	다른 유저가 모두 죽어서 1명이 남거나,
	//	다른 유저가 모두 나가서 1명이 남아도,
	//
	//	승리자의 화면은 승리문구가 표시됨. 
	//
	//  승리와 동시에 게임은 종료 되었으므로, 승리자를 제외한 다른 유저들에게는
	//	GAMEOVER 패킷을 보내주어야 함
	//
	//	게임종료 후 5초 뒤에 자동으로 방을 파괴 시킨다. (유저가 알아서 나간다면 당연히 파괴시킨다)
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_WINNER,

	//------------------------------------------------------------
	// GameOver
	//
	//	{
	//		WORD	Type
	//	}
	//
	//	게임 종료시 승리자를 제외한 다른 유저들에게 GameOver 패킷 전송.
	//
	//	승리자 없으 모두가 죽어버렸을시 본 패킷을 모두에게 전송
	//	종료된 게임방은 5초후에 파괴된다.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_GAMEOVER,



	//------------------------------------------------------------
	// 전적 변경내용 알림
	//
	//	{
	//		WORD	Type
	//
	//		int		Record_PlayCount	// 플레이 횟수
	//		int		Record_PlayTime		// 플레이 시간 초단위
	//		int		Record_Kill			// 죽인 횟수
	//		int		Record_Die			// 죽은 횟수
	//		int		Record_Win			// 최종승리 횟수
	//	}
	//
	//	플레이어 전적에 변화가 생겼을때 패킷을 보내준다.
	//	이는 플레이중에 보내는것은 아니며,  결과가 났을때 보냄
	//
	//	죽었을 때
	//	승리했을 때
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_RECORD,



	//------------------------------------------------------------
	// 배틀서버 방에서 유저가 나감 (GAME 전용)
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		INT64	AccountNo
	//	}
	// 플레이중인 방에서 유저가 나감을 알림
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_LEAVE_USER,





	//------------------------------------------------------------
	// 하트비트
	//
	//	{
	//		WORD		Type
	//	}
	//
	// 클라이언트는 이를 20초마다 보내줌. 서버는 30초 이상동안 통신이 없는 클라이언트를 강제로 끊어줘야 함.
	//------------------------------------------------------------	
	en_PACKET_CS_GAME_REQ_HEARTBEAT,











	////////////////////////////////////////////////////////
	//------------------------------------------------------
	// Matchmaking Server
	//------------------------------------------------------
	en_PACKET_CS_MATCH_SERVER				= 2000,

	//------------------------------------------------------------
	// 매치메이킹 서버로 로그인 요청
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		char	SessionKey[64];
	//	
	//		UINT	Ver_Code
	//	}
	//
	//	매치메이킹 서버는 클라이언트 접속시 SessionKey 를 shDB 에서 확인하여 로그인 인증 함.
	//	접속 후 클라이언트 고유 키 (Client Key) 를 생성하여 관리한다. (전 매치메이킹 서버 대상의 유니크 값 이어야 함)
	//
	//	Client Key 의 용도는 마스터 서버에서 클라이언트를 구분하는 값으로 
	//	매치메이킹 서버가 마스터 서버에게 방 생성 요청, 입장확인 시 사용 함.
	//
	//  AccountNo 는 새로운 접속시 중복되므로 사용 할 수 없음.
	//
	//  매치메이킹 서버코드 들어감. 버전 코드는 단순 숫자가 아니며 고유 값으로 부여됨.
	//------------------------------------------------------------
	en_PACKET_CS_MATCH_REQ_LOGIN,


	//------------------------------------------------------------
	// 매치메이킹 서버에서 로그인 결과  
	//
	//	{
	//		WORD	Type
	//
	//		BYTE	Status			1 : 성공
	//								2 : 세션키 오류
	//								3 : AccountNo 없음
	//								4 : 기타 오류
	//								5 : 버전오류
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_MATCH_RES_LOGIN,


	//------------------------------------------------------------
	// 방 정보 요청
	//
	//	{
	//		WORD	Type
	//	}
	//
	//	클라이언트가 매치메이킹 서버에게 방 정보를 요청 함.
	//
	//	매치메이킹 서버는 마스터 서버에게 ClientKey 와 방정보 요청을 보낸 뒤
	//	마스터 서버에게서 받은 정보를 클라이언트에게 돌려주면 된다.
	//------------------------------------------------------------
	en_PACKET_CS_MATCH_REQ_GAME_ROOM,
	
	//------------------------------------------------------------
	// 방 정보 결과
	//
	//	{
	//		WORD	Type
	//
	//		BYTE	Status				1 : 방 정보 얻기 성공 (아래 정보 있음)
	//									0 : 방 정보 얻기 실패 (아래 정보 없음 / 클라이언트가 일정시간 후 재요청 해야 함)
	//
	//		WORD	BattleServerNo		배틀서버 고유번호
	//
	//		WCHAR	IP[16]				배틀서버 접속 IP
	//		WORD	Port				배틀서버 접속 Port
	//
	//		int		RoomNo				배틀서버 내 게임방 번호
	//		char	ConnectToken[32]	배틀서버 접속 토큰 (배틀서버 발행)
	//		char	EnterToken[32]		배틀서버 장 입장 토큰 (배틀서버 발행)
	//
	//		WCHAR	ChatServerIP[16]
	//		WORD	ChatServerPort
	//
	//		INT64	ClientKey
	//	}
	//
	//	배틀서버 관련 정보는 배틀서버가 마스터 서버에게 전달한 정보이며
	//	매치메이킹 서버는 마스터 서버에게서 이를 받아 클라이언트 에게 전달 한다.
	//
	//	클라이언트도 자신의 고유한 ClientKey 를 받도록 한다.
	//	이 ClientKey 는 클라이언트가 배틀서버 입장시 배틀서버에게 전달 한다.
	//------------------------------------------------------------
	en_PACKET_CS_MATCH_RES_GAME_ROOM,


	//------------------------------------------------------------
	// 방 입장 성공 알림
	//
	//	{
	//		WORD	Type
	//
	//		WORD	BattleServerNo
	//		int		RoomNo
	//	}
	//
	//	클라이언트는 en_PACKET_CS_MATCH_RES_GAME_ROOM 방 정보를 받으면 배틀서버에 접속을 시도한다.
	//
	//	클라이언트가 배틀서버로 부터 방 입장 성공 안내를 받기 전 까지는
	//	매치메이킹 서버와 배틀서버 2개의 서버에 모두 접속을 유지하고 있음
	//
	//	배틀서버 방 입장이 성공되면, 매치메이킹 서버에게 이 패킷을 보내서 방 입장 성공을 알려줌.
	//
	//	매치메이킹 서버는 본 패킷을 받으면 마스터 서버에게 전달 해주며, 실제 해당 방의 접속자 인원을 변경 한다.
	//------------------------------------------------------------
	en_PACKET_CS_MATCH_REQ_GAME_ROOM_ENTER,

	//------------------------------------------------------------
	// 방 입장 성공 확인
	//
	//	{
	//		WORD	Type
	//	}
	//
	//	매치메이킹 서버는 위의 방 입장 성공 패킷을 받으면 마스터 서버에게 이를 전달
	//
	//	이 패킷을 받으면 클라이언트는 매치메이킹 서버와의 연결을 끊게 된다.
	//	굳이 RES 확인 패킷이 있는 이유는, 클라이언트가 일방적으로 보내고 끊어 버리면 
	//	매치메이킹 서버에게 100% 전달 되었다는 확신이 어려울 수 있으므로 REQ 와 RES 를 두어서 진행.
	//------------------------------------------------------------
	en_PACKET_CS_MATCH_RES_GAME_ROOM_ENTER,


	






	////////////////////////////////////////////////////////
	//
	//   Server & Server Protocol 
	//
	////////////////////////////////////////////////////////
	en_PACKET_SS_LAN					= 10000,
	//------------------------------------------------------
	// Matchmaking Server <-> Master Server <-> Battle Server <-> Chatting Server
	//------------------------------------------------------






	////////////////////////////////////////////////////////
	//------------------------------------------------------
	// Matchmaking Server <-> Master Server
	//------------------------------------------------------
	en_PACKET_MAT_MAS					= 10000,

	//------------------------------------------------------------
	//	매치메이킹 서버가 마스터 서버에게 서버 켜짐 알림 (로그인)
	//
	//	{
	//		WORD	Type
	//
	//		int		ServerNo			// 매칭서버 번호
	//		char	MasterToken[32]		// 마스터 서버 연결 인증 토큰
	//									// 이는 사전에 서로 합의된 토큰을 정해서 가지고 있어야 함
	//	}
	//
	//	딱히 필요는 없으나 혹시모를 안전을 위해서 추가 함.
	//
	//	Lan 통신의 경우 안전한 통신만 하는것을 기본으로 가지만, 우리 프로그램 외에 다른 프로그램이
	//	실수,임의로 연결하게 될 수 있으므로 연결 인증 과정을 추가 한다.
	//
	//	Master 서버에는 고정된 토큰을 가지고 있으며 (Config 로 지정) 
	//	Matchmaking 서버도 사전에 같은 토큰을 가지고 있어야 함 (Config 로 지정)
	//
	//	보안을 위해서 Master 서버는 인증을 통하지 않은 Matchmaking 서버들의 컨텐츠를 차단 한다.
	//	Master 서버는 토큰이 다르다면 로그 남기고 그냥 끊어버림. 별도의 안내 없음.
	//
	//
	//	추가로 Matchmaking Server No 를 관리하여 중복 ServerNo 가 들어오는 경우는
	//	차단 & 로그 작업이 들어가도 좋음
	//------------------------------------------------------------
	en_PACKET_MAT_MAS_REQ_SERVER_ON,

	//------------------------------------------------------------
	//	매치메이킹 서버의 켜임 수신 확인
	//
	//	{
	//		WORD	Type
	//
	//		int		ServerNo
	//	}
	//
	//	이제부터 Matchmaking 서버와 Master 서버 와의 통신이 가능 해졌다.
	//
	//	토큰이 달라서 로그인이 안되는 상태라면 응답 없이 마스터가 끊어버림.
	//------------------------------------------------------------
	en_PACKET_MAT_MAS_RES_SERVER_ON,



	//------------------------------------------------------------
	//	매치메이킹 서버가 마스터 서버에게 게임방 정보를 요청
	//
	//	{
	//		WORD	Type
	//
	//		UINT64	ClientKey			클라이언트 고유 키 (매치메이킹 서버가 생성한 클라이언트 유니크 키)
	//	}
	//
	//	매치메이킹 서버는 클라이언트에게 게임방 정보 요청을 받으면, 이 패킷을 마스터 서버에게 보냄
	//  매치메이킹 서버는 해당 클라이언트를 유니크하게 구분할 수 있는 ClientKey 를 생성하며
	//	마스터 서버 - 배틀서버 간에 이 ClientKey 를 사용하여 관리함.
	//------------------------------------------------------------
	en_PACKET_MAT_MAS_REQ_GAME_ROOM,

	//------------------------------------------------------------
	//	마스터 서버가 응답하는 게임방 정보
	//
	//	{
	//		WORD	Type
	//
	//		UINT64	ClientKey			클라이언트 고유 키 (매치메이킹 서버가 생성한 클라이언트 유니크 키)
	//
	//		BYTE	Status				1 : 방 정보 얻기 성공 (아래 정보 있음)
	//									0 : 방 정보 얻기 실패 (아래 정보 없음)
	//
	//		WORD	BattleServerNo		배틀서버 고유번호
	//		WCHAR	IP[16]				배틀서버 접속 IP
	//		WORD	Port				배틀서버 접속 Port
	//		int		RoomNo				배틀서버 내 게임방 번호
	//		char	ConnectToken[32]	배틀서버 접속 토큰 (배틀서버 발행)
	//		char	EnterToken[32]		배틀서버 장 입장 토큰 (배틀서버 발행)
	//
	//		WCHAR	ChatServerIP[16]
	//		WORD	ChatServerPort
	//
	//	}
	//
	//
	//	마스터 서버는 입장 가능한 게임방이 있는경우 즉각 결과를 알려주지만
	//	지금 대기 방이 없다면, '방 정보 얻기 실패' 패킷을 돌려준다. 
	//
	//	매치메이킹 서버는 이 정보를 그대로 클라이언트 에게 전달하며
	//	방 얻기 실패시 클라이언트는 일정시간 후 재 시도를 하게 될 것이다.
	//
	//	
	//------------------------------------------------------------
	en_PACKET_MAT_MAS_RES_GAME_ROOM,
	


	//------------------------------------------------------------
	//	유저의 방 입장 성공 안내
	//
	//	{
	//		WORD	Type
	//
	//		WORD	BattleServerNo
	//		int		RoomNo
	//		UINT64	ClientKey			클라이언트 고유 키 (매치메이킹 서버가 생성한 클라이언트 유니크 키)
	//	}
	//
	//	Master 서버는 해당 클라이언트 키를 탐색하여 어떤 Client 가 어떤 방에 입장을 성공 하였는지 인원을 갱신 한다.
	//
	//	(Battle 서버와 동기화 없음 / 클라이언트의 입장 확인을 하므로 )
	//	(Battle 서버가 들어왔던 유저가 나가는 경우에만 Master 서버로 인원 동기화를 함 )
	//
	//	BattleServerNo 와 RoomNo 가 있는 이유는 확인차 있는 부분.
	//------------------------------------------------------------
	en_PACKET_MAT_MAS_REQ_ROOM_ENTER_SUCCESS,


	//------------------------------------------------------------
	//	유저의 방 입장 실패 안내
	//
	//	{
	//		WORD	Type
	//
	//		UINT64	ClientKey			클라이언트 고유 키 (매치메이킹 서버가 생성한 클라이언트 유니크 키)
	//	}
	//
	//	Master 서버는 해당 클라이언트 키를 탐색하여
	//	해당 클라이언트에게 배정 됐던 방의 참여인원을 되돌린다.
	//
	//  
	//------------------------------------------------------------
	en_PACKET_MAT_MAS_REQ_ROOM_ENTER_FAIL,










	////////////////////////////////////////////////////////
	//------------------------------------------------------
	// Battle Server <-> Master Server
	//------------------------------------------------------
	en_PACKET_BAT_MAS						= 10100,

	//
	// 마스터가 서버 / 배틀이 클라이언트 입장이므로 
	//
	// 배틀 -> 마스터 Request
	// 마스터 -> 배틀 Response 
	// 
	// 개념으로 본다.
	//

	//------------------------------------------------------------
	//	배틀서버가 마스터 서버에게 서버 켜짐 알림
	//
	//	{
	//		WORD	Type
	//
	//		WCHAR	ServerIP[16]
	//		WORD	Port
	//		char	ConnectToken[32]	배틀서버 접속 토큰 (배틀서버 발행)
	//		char	MasterToken[32]		마스터 서버 접속 토큰 (사전에 지정된 값)
	//
	//		WCHAR	ChatServerIP[16]
	//		WORD	ChatServerPort
	//	}
	//
	//	배틀서버의 접속정보를 마스터 서버에게 등록하는 과정.
	//	배틀서버가 켜지면 마스터 서버에 Connect 후, 마스터 서버에게 이 패킷을 보낸다.
	//
	//	배틀서버의 고유 번호는 마스터 서버가 부여한다.
	//	배틀 서버마다 고유번호를 각자 관리하면 중복 및 추가시 번거로울 수 있으므로...
	//
	//	ConnectToken 은 최초 서버가 발행 후 주기적으로 갱신될 것이다.
	//
	//
	//	MasterToken 은 Master 서버가 가지고 있는 고정된 연결 토큰으로 각 배틀서버 설정파일에 들고 있어야 한다.
	//	MasterToken 이 다른 경우는 Battle 서버의 연결을 끊고 로그를 남긴다.
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_REQ_SERVER_ON,

	//------------------------------------------------------------
	//	배틀서버가 마스터 서버에게 서버 켜짐 응답
	//
	//	{
	//		WORD	Type
	//
	//		int		BattleServerNo			// 마스터 서버가 부여한 서버 번호
	//	}
	//
	//	배틀서버 On 에 대한 응답.
	//
	//	큰 의미는 없으며 내 배틀서버가 정상 등록 되었는지 확인하기 위함.
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_RES_SERVER_ON,


	//------------------------------------------------------------
	//	배틀서버의 연결토큰 재발행 알림.
	//
	//	{
	//		WORD	Type
	//
	//		char	ConnectToken[32]		// 배틀서버가 만든 연결 토큰
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	일정 시간마다 배틀서버는 연결토큰을 재발행 하여 마스터 서버에게 전달 한다.
	//	재발행 시간 주기는 배틀서버가 결정한다.
	//
	//	배틀서버는 토큰 발행 후  이전토큰 / 새토큰  2개를 보관해야 하며  
	//	이전 토큰으로 접속을 시도하는 사용자도 완전허용 또는 일정시간 허용을 해주어야 한다.
	//
	//	ReqSequence - TCP 의 시퀀스 번호같이 패킷의 순서 및 구분을 위한 카운팅 값
	//
	//
	//	배틀 <-> 마스터 사이에는 비슷하고 구분이 어려운 패킷들이 요청/응답을 반복적으로 하게 됨
	//	이 과정에서 요청과 응답을 혼동하여 잘못된 처리가 될 우려가 있으므로, 
	//	요청자가 시퀀스 번호를 +1 씩 부여하여 요청패킷을 보내면, 응답자는 이 시퀀스 번호를 사용하여 응답 한다.
	//
	//	만약을 위해서 넣은 기능이므로 불필요 하다면 사용하지 않아도 됨.
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_REQ_CONNECT_TOKEN,

	//------------------------------------------------------------
	//	배틀서버의 연결토큰 재발행 수신 확인
	//
	//	{
	//		WORD	Type
	//
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	마스터가 잘 수신 하였는지 확인용.  
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_RES_CONNECT_TOKEN,



	//------------------------------------------------------------
	//	배틀 서버의 신규 대기 방 생성 알림
	//
	//	{
	//		WORD	Type
	//
	//		int		BattleServerNo
	//		int		RoomNo
	//		int		MaxUser
	//		char	EnterToken[32]
	//
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	배틀서버는 자신이 보유한 대기방이 없을시 각자 알아서 1개 이상의 방을 생성하여 마스터 서버에게 전달 한다
	//	만약 방을 더 이상 만들 수 없는 상태라면 배틀 서버가 알아서 방생성을 중지한다. 
	//	그 이후 여유가 있을때 각자가 생성하여 마스터 서버에게 전달 한다.
	//
	//	마스터 서버가 하나하나 방 생성을 요청하지 않고,  배틀서버가 1개 이상의 대기방을 만들어서 알려주는 방식.
	//
	//	마스터 서버는 각 배틀서버의 IP/PORT 를 알고 있으므로 방에 관련 정보만 전달 한다
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_REQ_CREATED_ROOM,
	 
	//------------------------------------------------------------
	//	배틀 서버의 신규 대기 방 생성 수신 응답
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	큰 의미는 없으나 만약을 위해서 REQ / RES 짝을 맞춰 주도록 한다
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_RES_CREATED_ROOM,


	//------------------------------------------------------------
	//	방 닫힘 알림
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	대기방이 플레이를 위해, 또는 기타 사유로 인해서 방이 닫혀짐을 마스터에게 알림
	//	마스터 서버는 해당 방의 정보를 삭제하고 사용자를 배정하지 않는다.
	//
	//	대기방 -> 플레이		본 패킷 송신
	//	플레이 -> 종료		이미 플레이시 닫혔으므로 송신 하지 않음.
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_REQ_CLOSED_ROOM,

	//------------------------------------------------------------
	//	방 닫힘 수신확인
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	수신 확인용
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_RES_CLOSED_ROOM,
	

	//------------------------------------------------------------
	//	방에서 유저가 나갔음, 1명 나갈때 마다 전송.
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		INT64	ClientKey				// 나간 사용자 구분용
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	사용자가 들어가는 부분은 마스터 서버가 알아서 카운팅 하지만, 
	//	배틀서버에 들어갔다가 나간 유저는 마스터 서버가 파악 불가능.
	//
	//	그러므로 유저가 나갈 경우에만 배틀서버 -> 마스터서버 로 전달 한다.
	//
	//	현재 인원의 수치를 전달 하는것이 아닌 -1 값을 보내는 의미이므로 마스터서버는 
	//	해당 방에 배정된 ClientKey 를 확인하여 해당 인원을 차감(가용유저 증가) 시켜주면 됨.
	//
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_REQ_LEFT_USER,

	//------------------------------------------------------------
	//	방에서 유저가 나갔 수신 확인
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_RES_LEFT_USER,





	////////////////////////////////////////////////////////
	//------------------------------------------------------
	// Chat Server <-> Battle Server
	//------------------------------------------------------
	en_PACKET_CHAT_BAT						= 10500,

	//
	// 배틀서버가 LanServer / 채팅서버가 LanClient
	//
	// 채팅 -> 배틀 Request
	// 배틀 -> 채팅 Response 
	// 
	// 기본은 그러하나 꼭 REQ / RES 방향이 맞지 않음. 주석참고

	//------------------------------------------------------------
	//	채팅서버가 배틀서버에게 서버 켜짐 알림
	//
	//	{
	//		WORD	Type
	//
	//		WCHAR	ChatServerIP[16]	사용자가 접속하는 채팅서버 IP
	//		WORD	ChatServerPort		사용자가 접속하는 채팅서버 Port
	//	}
	//
	//	채팅서버가 켜지면 배틀서버에 LanClient -> LanServer 로 접속하여 본 패킷을 보낸다
	//
	//	배틀서버는 채팅서버의 정보를 전혀 가지고 있지 않으며, 
	//	채팅서버가 배틀서버에게 자신의 사용자 접속 IP/Port 를 알려주어 등록한다.
	//------------------------------------------------------------
	en_PACKET_CHAT_BAT_REQ_SERVER_ON,

	//------------------------------------------------------------
	//	채팅서버가 배틀서버에게 서버 켜짐 알림 확인
	//
	//	{
	//		WORD	Type
	//	}
	//
	//	채팅서버 On 에 대한 응답.
	//------------------------------------------------------------
	en_PACKET_CHAT_BAT_RES_SERVER_ON,



	//------------------------------------------------------------
	//	배틀서버의 연결토큰 재발행 채팅서버에게 알림.  (배틀 -> 채팅)
	//
	//	{
	//		WORD	Type
	//
	//		char	ConnectToken[32]		// 배틀서버가 만든 연결 토큰
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	마스터 서버에게 주는 토큰 재발행과 같음.
	//------------------------------------------------------------
	en_PACKET_CHAT_BAT_REQ_CONNECT_TOKEN,

	//------------------------------------------------------------
	//	배틀서버의 연결토큰 재발행 수신 확인	(채팅 -> 배틀)
	//
	//	{
	//		WORD	Type
	//
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	채팅이 배틀에게 주는 응답 확인용  
	//------------------------------------------------------------
	en_PACKET_CHAT_BAT_RES_CONNECT_TOKEN,



	//------------------------------------------------------------
	//	배틀 서버의 신규 대기 방 생성 채팅서버에게 알림  (배틀 -> 채팅)
	//
	//	{
	//		WORD	Type
	//
	//		int		BattleServerNo
	//		int		RoomNo
	//		int		MaxUser
	//		char	EnterToken[32]
	//
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	배틀서버는 방 생성시 마스터 서버와 채팅서버 에게도 이를 안내한다.
	//	채팅서버는 해당 채팅방을 생성시킨다.
	//------------------------------------------------------------
	en_PACKET_CHAT_BAT_REQ_CREATED_ROOM,
	 
	//------------------------------------------------------------
	//	배틀 서버의 신규 대기 방 생성 수신 응답	(채팅 -> 배틀)
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	큰 의미는 없으나 만약을 위해서 REQ / RES 짝을 맞춰 주도록 한다
	//------------------------------------------------------------
	en_PACKET_CHAT_BAT_RES_CREATED_ROOM,


	//------------------------------------------------------------
	//	배틀 서버의 방 삭제를 채팅서버에게 알림  (배틀 -> 채팅)
	//
	//	{
	//		WORD	Type
	//
	//		int		BattleServerNo
	//		int		RoomNo
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	배틀서버가 방을 삭제할 때 채팅서버에게 보낸다.
	//	(Ready / Play 상태의 방 닫힘이 아니며 진짜 방 파괴)
	//
	//  채팅서버의 해당 방에 유저가 있는 경우는 끊는다.
	//
	//	필요 없을줄 알았으나... 필요성이 생겨서 추가 함. ;;;
	//------------------------------------------------------------
	en_PACKET_CHAT_BAT_REQ_DESTROY_ROOM,
	 
	//------------------------------------------------------------
	//	방 삭제 처리 확인						(채팅 -> 배틀)
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	큰 의미는 없으나 만약을 위해서 REQ / RES 짝을 맞춰 주도록 한다
	//------------------------------------------------------------
	en_PACKET_CHAT_BAT_RES_DESTROY_ROOM,












	//------------------------------------------------------
	// Monitor Server Protocol
	//------------------------------------------------------


	////////////////////////////////////////////////////////
	//
	//   MonitorServer & MoniterTool Protocol / 응답을 받지 않음.
	//
	////////////////////////////////////////////////////////

	//------------------------------------------------------
	// Monitor Server  Protocol
	//------------------------------------------------------
	en_PACKET_SS_MONITOR					= 20000,
	//------------------------------------------------------
	// Server -> Monitor Protocol
	//------------------------------------------------------
	//------------------------------------------------------------
	// LoginServer, GameServer , ChatServer , Agent 가 모니터링 서버에 로그인 함
	//
	// 
	//	{
	//		WORD	Type
	//
	//		int		ServerNo		// 서버 타입 없이 각 서버마다 고유 번호를 부여하여 사용
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_SS_MONITOR_LOGIN,

	//------------------------------------------------------------
	// 서버가 모니터링서버로 데이터 전송
	// 각 서버는 자신이 모니터링중인 수치를 1초마다 모니터링 서버로 전송.
	//
	// 서버의 다운 및 기타 이유로 모니터링 데이터가 전달되지 못할떄를 대비하여 TimeStamp 를 전달한다.
	// 이는 모니터링 클라이언트에서 계산,비교 사용한다.
	// 
	//	{
	//		WORD	Type
	//
	//		BYTE	DataType				// 모니터링 데이터 Type 하단 Define 됨.
	//		int		DataValue				// 해당 데이터 수치.
	//		int		TimeStamp				// 해당 데이터를 얻은 시간 TIMESTAMP  (time() 함수)
	//										// 본래 time 함수는 time_t 타입변수이나 64bit 로 낭비스러우니
	//										// int 로 캐스팅하여 전송. 그래서 2038년 까지만 사용가능
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_SS_MONITOR_DATA_UPDATE,


	en_PACKET_CS_MONITOR					= 25000,
	//------------------------------------------------------
	// Monitor -> Monitor Tool Protocol  (Client <-> Server 프로토콜)
	//------------------------------------------------------
	//------------------------------------------------------------
	// 모니터링 클라이언트(툴) 이 모니터링 서버로 로그인 요청
	//
	//	{
	//		WORD	Type
	//
	//		char	LoginSessionKey[32]		// 로그인 인증 키. (이는 모니터링 서버에 고정값으로 보유)
	//										// 각 모니터링 툴은 같은 키를 가지고 들어와야 함
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_MONITOR_TOOL_REQ_LOGIN,

	//------------------------------------------------------------
	// 모니터링 클라이언트(툴) 모니터링 서버로 로그인 응답
	// 로그인에 실패하면 0 보내고 끊어버림
	//
	//	{
	//		WORD	Type
	//
	//		BYTE	Status					// 로그인 결과 0 / 1 
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_MONITOR_TOOL_RES_LOGIN,

	//------------------------------------------------------------
	// 모니터링 서버가 모니터링 클라이언트(툴) 에게 모니터링 데이터 전송
	//
	// 모니터링 서버는 모든 모니터링 클라이언트에게 모든 데이터를 뿌려준다.
	//
	// 데이터를 절약하기 위해서는 초단위로 모든 데이터를 묶어서 30~40개의 모니터링 데이터를 하나의 패킷으로 만드는게
	// 좋으나  여러가지 생각할 문제가 많으므로 그냥 각각의 모니터링 데이터를 개별적으로 전송처리 한다.
	//
	//	{
	//		WORD	Type
	//		
	//		BYTE	ServerNo				// 서버 No
	//		BYTE	DataType				// 모니터링 데이터 Type 하단 Define 됨.
	//		int		DataValue				// 해당 데이터 수치.
	//		int		TimeStamp				// 해당 데이터를 얻은 시간 TIMESTAMP  (time() 함수)
	//										// 본래 time 함수는 time_t 타입변수이나 64bit 로 낭비스러우니
	//										// int 로 캐스팅하여 전송. 그래서 2038년 까지만 사용가능
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_MONITOR_TOOL_DATA_UPDATE,

/*
	원격 제어 기능을 사용하지 않을 것이므로 생략 됨.
	//------------------------------------------------------------
	// 모니터링 클라이언트(툴) 가 모니터링 서버에게 서버 컨트롤
	//
	// 이는 모니터링 서버에서 각 클라(모니터링 툴) 에게 지정된 서버의 에이전트에게 재전달 됨.
	// * 채팅서버는 Shutdown 기능이 없음.  
	//
	//	{
	//		WORD	Type
	//
	//		BYTE	ServerType				// 컨트롤 대상 서버  하단 Define 사용
	//		BYTE	Control					// 컨트롤 명령, Run / Terminate / Shutdown   하단 Define 사용
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_MONITOR_TOOL_SERVER_CONTROL,
*/

};



enum en_PACKET_CS_LOGIN_RES_LOGIN 
{
	dfLOGIN_STATUS_NONE				= -1,		// 미인증상태
	dfLOGIN_STATUS_FAIL				= 0,		// 세션오류
	dfLOGIN_STATUS_OK				= 1,		// 성공
	dfLOGIN_STATUS_GAME				= 2,		// 게임중
	dfLOGIN_STATUS_ACCOUNT_MISS		= 3,		// account 테이블에 AccountNo 없음
	dfLOGIN_STATUS_SESSION_MISS		= 4,		// Session 테이블에 AccountNo 없음
	dfLOGIN_STATUS_STATUS_MISS		= 5,		// Status 테이블에 AccountNo 없음
	dfLOGIN_STATUS_NOSERVER			= 6,		// 서비스중인 서버가 없음.
};


enum en_PACKET_CS_GAME_RES_LOGIN 
{
	dfGAME_LOGIN_FAIL				= 0,		// 세션키 오류 또는 Account 데이블상의 오류
	dfGAME_LOGIN_OK					= 1,		// 성공
	dfGAME_LOGIN_NOCHARACTER		= 2,		// 성공 / 캐릭터 없음 > 캐릭터 선택화면으로 전환. 
	dfGAME_LOGIN_VERSION_MISS		= 3,		// 서버,클라 버전 다름
};


// en_PACKET_SS_MONITOR_LOGIN
enum en_PACKET_CS_MONITOR_TOOL_SERVER_CONTROL
{
	dfMONITOR_SERVER_TYPE_LOGIN		= 1,
	dfMONITOR_SERVER_TYPE_GAME		= 2,
	dfMONITOR_SERVER_TYPE_CHAT		= 3,
	dfMONITOR_SERVER_TYPE_AGENT		= 4,

	dfMONITOR_SERVER_CONTROL_SHUTDOWN			= 1,		// 서버 정상종료 (게임서버 전용)
	dfMONITOR_SERVER_CONTROL_TERMINATE			= 2,		// 서버 프로세스 강제종료
	dfMONITOR_SERVER_CONTROL_RUN				= 3,		// 서버 프로세스 생성 & 실행
};


enum en_PACKET_SS_MONITOR_DATA_UPDATE
{
	// 별도의 에이전트(서버 컨트롤용) 프로그램이 없으므로 하드웨어 자체의 모니터링 수집은
	// 매치메이킹 서버가 전담 하도록 합니다..

	// 2U 서버 1대에 매치메이킹 / 배틀 / 채팅  3대의 서버가 가동 되겠습니다.

	// 본래 서버 프로세스 ON 여부는 외부에서 판단하여 보내야 하지만
	// 에이전트 없이 진행 되므로 자기 자신이 보내는것으로 합니다.
	// 다만 꺼지면 해당 데이터 자체가 안가기 때문에 일정시간 후에 모니터링 툴은 OFF 로 인식하게 됩니다.
	// OFF 판단까지 5초~10초 정도 시간이 소요되지만 그렇게 합니다.


	// 라이브 서비스 환경
	// 마스터서버		ServerNo	0  공용 1대
	// 매치 서버			ServerNo	1, 11, 21, 31, 41
	// 배틀 서버			ServerNo	2, 12, 22, 32, 42
	// 채팅서버			ServerNo	3, 13, 23, 33, 43

	// 이주행 서버  매칭(1) 배틀(2) 채팅(3)
	// 신완철 서버  매칭(11) 배틀(12) 채팅(13)
	// 안상민 서버  매칭(21) 배틀(22) 채팅(23)
	// 김준민 서버  매칭(31) 배틀(32) 채팅(33)

	// 아래 수치는 enum 이므로 모니터링 클라에서 해당 숫자값 제대로 확인하여 사용

	dfMONITOR_DATA_TYPE_SERVER_CPU_TOTAL = 1,                    // 하드웨어 CPU 사용률 전체
	dfMONITOR_DATA_TYPE_SERVER_AVAILABLE_MEMORY,                 // 하드웨어 사용가능 메모리
	dfMONITOR_DATA_TYPE_SERVER_NETWORK_RECV,                     // 하드웨어 이더넷 수신 kb
	dfMONITOR_DATA_TYPE_SERVER_NETWORK_SEND,                     // 하드웨어 이더넷 송신 kb
	dfMONITOR_DATA_TYPE_SERVER_NONPAGED_MEMORY,                  // 하드웨어 논페이지 메모리 사용량

	dfMONITOR_DATA_TYPE_MATCH_SERVER_ON,                        // 매치메이킹 서버 ON
	dfMONITOR_DATA_TYPE_MATCH_CPU,                              // 매치메이킹 CPU 사용률 (커널 + 유저)
	dfMONITOR_DATA_TYPE_MATCH_MEMORY_COMMIT,                    // 매치메이킹 메모리 유저 커밋 사용량 (Private) MByte
	dfMONITOR_DATA_TYPE_MATCH_PACKET_POOL,                      // 매치메이킹 패킷풀 사용량
	dfMONITOR_DATA_TYPE_MATCH_SESSION,                          // 매치메이킹 접속 세션
	dfMONITOR_DATA_TYPE_MATCH_PLAYER,                           // 매치메이킹 접속 유저 (로그인 성공 후)
	dfMONITOR_DATA_TYPE_MATCH_MATCHSUCCESS,                     // 매치메이킹 방 배정 성공 수 (초당)


	dfMONITOR_DATA_TYPE_MASTER_SERVER_ON,                        // 마스터 서버 ON
	dfMONITOR_DATA_TYPE_MASTER_CPU,                              // 마스터 CPU 사용률 (프로세스)
	dfMONITOR_DATA_TYPE_MASTER_CPU_SERVER,                       // 마스터 CPU 사용률 (서버 컴퓨터 전체)
	dfMONITOR_DATA_TYPE_MASTER_MEMORY_COMMIT,                    // 마스터 메모리 유저 커밋 사용량 (Private) MByte
	dfMONITOR_DATA_TYPE_MASTER_PACKET_POOL,                      // 마스터 패킷풀 사용량
	dfMONITOR_DATA_TYPE_MASTER_MATCH_CONNECT,                    // 마스터 매치메이킹 서버 연결 수
	dfMONITOR_DATA_TYPE_MASTER_MATCH_LOGIN,                      // 마스터 매치메이킹 서버 로그인 수
	dfMONITOR_DATA_TYPE_MASTER_STAY_CLIENT,                      // 마스터 대기자 클라이언트
	dfMONITOR_DATA_TYPE_MASTER_BATTLE_CONNECT,                   // 마스터 배틀 서버 연결 수
	dfMONITOR_DATA_TYPE_MASTER_BATTLE_LOGIN,                     // 마스터 배틀 서버 로그인 후
	dfMONITOR_DATA_TYPE_MASTER_BATTLE_STANDBY_ROOM,              // 마스터 배틀 서버 대기방



	dfMONITOR_DATA_TYPE_BATTLE_SERVER_ON,                       // 배틀서버 ON
	dfMONITOR_DATA_TYPE_BATTLE_CPU,                             // 배틀서버 CPU 사용률 (커널 + 유저)
	dfMONITOR_DATA_TYPE_BATTLE_MEMORY_COMMIT,                   // 배틀서버 메모리 유저 커밋 사용량 (Private) MByte
	dfMONITOR_DATA_TYPE_BATTLE_PACKET_POOL,                     // 배틀서버 패킷풀 사용량
	dfMONITOR_DATA_TYPE_BATTLE_AUTH_FPS,                        // 배틀서버 Auth 스레드 초당 루프 수
	dfMONITOR_DATA_TYPE_BATTLE_GAME_FPS,                        // 배틀서버 Game 스레드 초당 루프 수
	dfMONITOR_DATA_TYPE_BATTLE_SESSION_ALL,                     // 배틀서버 접속 세션전체
	dfMONITOR_DATA_TYPE_BATTLE_SESSION_AUTH,                    // 배틀서버 Auth 스레드 모드 인원
	dfMONITOR_DATA_TYPE_BATTLE_SESSION_GAME,                    // 배틀서버 Game 스레드 모드 인원
	dfMONITOR_DATA_TYPE_BATTLE_,		                        // 배틀서버 로그인을 성공한 전체 인원		<- 삭제
	dfMONITOR_DATA_TYPE_BATTLE_ROOM_WAIT,                       // 배틀서버 대기방 수
	dfMONITOR_DATA_TYPE_BATTLE_ROOM_PLAY,                       // 배틀서버 플레이방 수

	dfMONITOR_DATA_TYPE_CHAT_SERVER_ON,                         // 채팅서버 ON
	dfMONITOR_DATA_TYPE_CHAT_CPU,                               // 채팅서버 CPU 사용률 (커널 + 유저)
	dfMONITOR_DATA_TYPE_CHAT_MEMORY_COMMIT,                     // 채팅서버 메모리 유저 커밋 사용량 (Private) MByte
	dfMONITOR_DATA_TYPE_CHAT_PACKET_POOL,                       // 채팅서버 패킷풀 사용량
	dfMONITOR_DATA_TYPE_CHAT_SESSION,                           // 채팅서버 접속 세션전체
	dfMONITOR_DATA_TYPE_CHAT_PLAYER,                            // 채팅서버 로그인을 성공한 전체 인원
	dfMONITOR_DATA_TYPE_CHAT_ROOM,                               // 배틀서버 방 수

	dfMONITOR_DATA_TYPE_ALL_MATCH_PLAYER,                         // 전체 매칭서버 접속 플레이어 수
	dfMONITOR_DATA_TYPE_ALL_BATTLE_PLAYER,                       // 전체 배틀 접속 플레이어 수
	dfMONITOR_DATA_TYPE_ALL_CHAT_PLAYER                         // 전체 채팅 접속 플레이어 수

};

// MEMORY_COMMIT 사이즈는 PDH 다음 쿼리를 사용 합니다    "\\Process(NAME)\\Private Bytes"



//#endif